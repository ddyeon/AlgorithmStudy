## 백준 14502 연구소

&nbsp;
### 🧐문제
인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.

연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 

일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.

2 0 0 0 1 1 0  
0 0 1 0 1 2 0  
0 1 1 0 1 0 0  
0 1 0 0 0 0 0  
0 0 0 0 0 1 1  
0 1 0 0 0 0 0  
0 1 0 0 0 0 0  
이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.

2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.

2 1 0 0 1 1 0  
1 0 1 0 1 2 0  
0 1 1 0 1 0 0  
0 1 0 0 0 1 0  
0 0 0 0 0 1 1  
0 1 0 0 0 0 0  
0 1 0 0 0 0 0  
바이러스가 퍼진 뒤의 모습은 아래와 같아진다.

2 1 0 0 1 1 2  
1 0 1 0 1 2 2  
0 1 1 0 1 2 2  
0 1 0 0 0 1 2  
0 0 0 0 0 1 1  
0 1 0 0 0 0 0  
0 1 0 0 0 0 0  
벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.

연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.
&nbsp;

>입력 

    첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.빈 칸의 개수는 3개 이상이다.

>출력

    첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.

***
&nbsp;
### 코드
```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
//0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳
int n,m;
int arr[8][8];
int tmp[8][8];
int dx[4] = {0,1,-1,0};
int dy[4] = {1,0,0,-1};
int wall = 3;
int max_cnt = 0;

void mapCopy(int (*a)[8], int (*b)[8]){
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            a[i][j] = b[i][j];
}



void bfs() {
    int spread[8][8];
    mapCopy(spread, tmp);
    queue<pair<int,int>> q;
    for(int i = 0; i< n; i++) {
        for(int j = 0; j < m; j++) {
            if(spread[i][j] == 2) q.push({i,j});
        }
    }
    //바이러스 퍼트리기
    while(!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        for(int i = 0; i < 4; i++) {
            for(int j = 0; j < 4; j++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if(0<=nx && nx<n && 0<=ny && ny<m){
                    if(spread[nx][ny] == 0)  {
                        spread[nx][ny] = 2;
                        q.push({nx,ny});
                    }
                }
                
            }
        }
    }
    
    int cnt = 0; //안전영역 개수 
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(spread[i][j] == 0) cnt++;
        }
    }
    
    max_cnt = max(max_cnt, cnt);
  
}

void wall_cnt(int cnt) {
    if(cnt == 3) {
        bfs();
        return;
    }
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(tmp[i][j] == 0) {
                tmp[i][j] = 1;
                wall_cnt(cnt+1);
                tmp[i][j] = 0; //다시 초기화
            }
        }
    }
}



int main() {
    cin >> n >> m;
    
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            cin >> arr[i][j];
        }
    }
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(arr[i][j] == 0) {
                mapCopy(tmp, arr);
                tmp[i][j] = 1;
                wall_cnt(1);
                tmp[i][j] = 0;
                
            }
        }
    }
    
    cout << max_cnt << endl;

    return 0;
}

```
***

&nbsp;

### 👩🏻‍💻풀이 방식
이 문제는 dfs도 있고 bfs도 이용해야 하는 문제이다.  
문제풀이 순서는 
1. 0인지점으로 한개의 벽을 세운다.
2. 1개의 벽을 세운 map을 이용하여 나머지 2개의 벽도 세워 맵을 완성한다.
3. 해당 맵을 bfs를 이용하여 바이러스를 퍼트린다.
4. 안전영역 개수를 체크하고 최대값과 비교한다.

벽을 세울때에는 복사한 맵을 이용하고, 0인곳을 최대 3까지 1로 재귀적으로 바꿔가며 맵을 완성한다. 이때, 다른 곳에 세울 수 도 있기 때문에 복사한 맵은 다시 0으로 바꿔준다.

바이러스를 카운팅 하는 bfs도 복사한 맵을 이용하여 현재 상황에서 바이러스를 퍼트릴 수 있도록 한다.


### 🕶회고
처음에는 벽을 세움과 동시에 안전영역을 체크하려고 bfs함수에 전부 넣으려고 했으나 방법이 떠오르지 않았다. 그리고 탐색에서 가장 어려운게 변경된 맵 값을 다시 되돌려주는 것을 생각하는게 어렵다. 꼭 다시 풀기!





[14502](https://www.acmicpc.net/problem/14502, "baekjoon")
