## 백준 달력 20207

&nbsp;
### 🧐문제
 수현이는 일년의 날짜가 1일부터 365일로 표시되어있는 달력을 가지고있다. 수현이는 너무나도 계획적인 사람이라 올 해 일정을 모두 계획해서 달력에 표시해놨다. 

여름이 거의 끝나가자 장마가 시작되었고, 습기로 인해 달력에 표시한 일정이 지워지려고 한다. 지워지는 것을 막고자 수현이는 일정이 있는 곳에만 코팅지를 달력에 붙이려고 한다. 하지만 너무 귀찮았던 나머지, 다음과 같은 규칙을 따르기로 한다.

연속된 두 일자에 각각 일정이 1개 이상 있다면 이를 일정이 연속되었다고 표현한다.
연속된 모든 일정은 하나의 직사각형에 포함되어야 한다. 
연속된 일정을 모두 감싸는 가장 작은 직사각형의 크기만큼 코팅지를 오린다.
달력은 다음과 같은 규칙을 따른다.

일정은 시작날짜와 종료날짜를 포함한다.
시작일이 가장 앞선 일정부터 차례대로 채워진다.
시작일이 같을 경우 일정의 기간이 긴 것이 먼저 채워진다.
일정은 가능한 최 상단에 배치된다.
일정 하나의 세로의 길이는 1이다. 
하루의 폭은 1이다.

&nbsp;

>입력 
    
    첫째 줄에 일정의 개수 N이 주어진다. (1 ≤ N ≤ 1000) 
    둘째 줄부터 일정의 개수만큼 시작 날짜 S와 종료 날짜 E가 주어진다. (1 ≤ S ≤ E ≤ 365)

>출력

    코팅지의 면적을 출력한다.


***
&nbsp;
### 코드
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;


int main() {
    int N;
    int arr[367] = {0,};

    cin >> N;
    for(int i=0; i< N; i++) {
        int temp_a, temp_b;
        cin >> temp_a >> temp_b;

        for(int j = temp_a; j<= temp_b; j++) {
            arr[j]++ ;
        }
    }

    int max_cnt = -1;
    int cnt = 0;
    int ans = 0;
    for(int i=1; i<= 366; i++) {
       if(arr[i] > 0) {
           cnt++;
           max_cnt =max(max_cnt,arr[i]);
       }
       if(arr[i-1] > 0 && arr[i] == 0) {
           ans += max_cnt * cnt;
           max_cnt =-1;
           cnt =0;
       }
    }

    cout <<  ans <<endl;
}
```
***

&nbsp;

### 👩🏻‍💻풀이 방식
365의 크기를 가진 배열에 해당되는 요일을 +1를 해준다.   
그 후 365일만큼 반복하면서 arr[i]가 0보다 크면 width가 증가하는 것으로 +1를 해준다.   
만약 예시값이 1-9, 2-4일경우 arr[2]~arr[4]는 값이 2일 것이고 이때 높이는 2가 될 것이다. 이를 활용하여 width를 증가해주면서 동시에 height에 max값을 찾아준다.   
만약 0 값이 나오면 일정이 없는 경우이니 지금까지의 사각형의 넓이를 ans에 더해준다.


### 🕶회고
366까지 반복문을 돌지 않아도 될 것 같은데.. 이부분 수정이 필요한 것 같다.
어렵다..!

[20207](https://www.acmicpc.net/problem/20207 "baekjoon")
